\documentclass[a4paper,12pt]{article}

\usepackage[dutch]{babel}
\usepackage{fancyhdr}
\usepackage{graphicx}
\usepackage[pdftex,bookmarks=true]{hyperref}
\usepackage[utf8]{inputenc}
\usepackage{fullpage}
\usepackage{parskip}
\usepackage{float}
\usepackage{subcaption}
\usepackage{listings}

\title{Samenvatting Databanken II \\ \large TIN 2 - HoGent}
\author{Lorenz Verschingel}

\begin{document}
\maketitle

\section{SQL}

\subsection{Inner join}
Voorbeeld van een inner join:
\begin{lstlisting}[language=sql]
SELECT au_lastName, au_FirstName, title_id
FROM authors
JOIN titleAuthor ON authors.au_id = titleauthor.au_id
\end{lstlisting}
Hier worden alle records van authors en titleAuthor aan elkaar gekoppeld op basis van au\_id.

\subsection{Aliassen}
Het gebruik van tabel aliassen gebeurt via het keyword 'AS' of door een spatie.

\begin{lstlisting}[language=sql]
SELECT au_lname, au_fname, title_id
FROM authors AS A
JOIN titleauthor TA ON A.au_id = TA.au_id
\end{lstlisting}

\subsection{Inner join van meerdere tabellen}
Gegevens kunnen ook over meerdere tabellen verspreid zitten. Hierbij moeten dan meerdere tabellen aan elkaar gekoppeld worden.
\begin{lstlisting}[language=sql]
SELECT au_lname, au_fname, title
FROM authors A
JOIN titleauthor TA ON A.au_id= TA.au_id
JOIN titles T ON TA.title_id= T.title_id
\end{lstlisting}
Het kan zijn dat er enkel gegevens uit 2 tabellen worden getoond, maar dat er in werkelijkheid meerdere tabellen gekoppeld zijn omdat het geen directe koppeling is tussen de tabellen waaruit de gegevens komen.

\subsection{Outer join}
Een outer join retourneert alle records van 1 tabel, zelfs als er geen gerelateerd record bestaat in de andere tabel.

Er zijn 3 types van outer join:
\begin{enumerate}
\item Left outer join retourneert alle rijen van de eerst genoemde tabel in de FROM clause.

In sql is dit de LEFT JOIN
\item Right outer join retourneert alle rijen van de tweede genoemde tabel in de FROM clause.

In sql is dit de RIGHT JOIN
\item Full outer join retourneert ook rijen uit de eerste en tweede tabel die geen corresponderende entry hebben in de andere tabel.

In sql is dit de CROSS JOIN
\end{enumerate}

\subsection{Union}
Via een UNION combineer je het resultaat van 2 of meerdere queriesin 1 resultaattabel.
\begin{lstlisting}[language=sql]
SELECT ... FROM ... WHERE ...
UNION
SELECT ... FROM ... WHERE ...
ORDER BY ...
\end{lstlisting}
Regels:
\begin{itemize}
\item De resultaten van de 2 SELECT opdrachten moeten evenveel kolommen bevatten.
\item Overeenkomstige kolommen uit beide SELECT’smoeten van hetzelfde data type zijn en beide NOT NULL toelaten of niet.
\item Kolommen komen voor in dezelfde volgorde
\item De kolomnamen/titels van de UNION zijn deze van de eerste SELECT
\item Het resultaat bevat echter steeds alleen unieke rijen
\item Aan het einde van de UNION kan je een ORDER BY toevoegen.
In deze clausule mag geen kolomnaam of uitdrukking voorkomen indien kolomnamen van beide select’sverschillen.
Gebruik in dat geval kolomnummers.
\end{itemize}

\subsection{Subqueries}
Bij een subquerykomt een selectie voor als onderdeel van een andere selectie.

\begin{lstlisting}[language=sql]
SELECT ...
FROM
WHERE voorwaarde
\end{lstlisting}

De voorwaarde bevat in het rechterlid tussen ronde haakjes een nieuwe SELECT.

De outer level query is de eerste select. Deze bevat de hoofdvraag.

De inner level query is de tweede select deze staat in de WHERE of HAVING clause.

We gebruiken subqueries om:
\begin{itemize}
\item een resultaat te retourneren waarbij de subquery een proces gegeven bevat.
\item gegevens uit meerdere tabellen te halen. Dit kan vergeleken worden met een JOIN.
Enkel worden bij subqueries de tabellen afzonderlijk gebruikt.
\end{itemize}

Er zijn drie vormen in de WHERE clause
\begin{enumerate}
\item Geneste subvragen
\item Gecorreleerde subvragen
\item Operator exists
\end{enumerate}

Subqueries kunnen ook voorkomen in de FROM en SELECT clause.

\subsubsection{Geneste subvragen}
De subvragen worden altijd eerst uitgevoerd en moeten steeds tussen haakjes staan. Subvragen kunnen in meerdere niveau's genest zijn.

Bij een geneste subquery kan de één waarde geretourneerd worden of een ganse lijst met waarden.

ANY en ALL keywords worden gebruikt in combinatie met de relationele operatoren en subqueriesdie een kolom van waarden retourneren.

\begin{itemize}
\item ALL retourneert TRUE als alle waarden geretourneerd in de subquer yvoldoenaande voorwaarde.
\item ANY retourneert TRUE als minstens 1 waarde geretourneerd in de subquery voldoet aan de voorwaarde.
\end{itemize}

\subsubsection{Gecorreleerde subqueries}
Bij een gecorreleerde subquery hangt de inner query af van informatie van de outer query. Voor elke rij uit de hoofdvraag wordt de subvraag opnieuw uitgevoerd. Bijgevolg gebruikt me beter JOIN als dit mogelijk is.

\begin{lstlisting}[language=sql]
SELECT ...
FROM tabel a
WHERE uitdrukking operator (
	SELECT ...
	FROM tabel
	WHERE uitdrukking operator a.kolomnaam)
\end{lstlisting}
In de hoofdvraag mag je geen velden gebruiken uit de subvraag, maar wel omgekeerd.

\subsubsection{Exists operator}
Via de operator EXISTS wordt getest op het al dan niet leeg zijn van een resultaatset. Er bestaat ook NOT EXISTS.

\section{Database ontwerp - DDL}
\subsection{Database}
\subsubsection{Een database creëren}
Bij creatie van een DB worden fysiek 2 files gemaakt: een datafile (mdf) en een logfile (ldf).
Er kunnen meerdere datafiles zijn, nl. de secondary data files (ndf).
Er kunnen ook meerdere logfiles zijn.

Bij creatie van een DB wordt een kopie genomen van de model database, deze bevat systeemtabellen en systeemviews.

Data wordt opgeslagen in blokken van 8 KB aaneensluitende diskspace, dit noemt met een pagina.
Eén rij kan niet op meerdere pagina’s bewaard worden, een rij mag maximaal 8060 b groot zijn (8KB – ruimte overhead).
8 opeenvolgende pagina’s worden 1 extend (64 KB).
Een tabel, index wordt opgeslagen in een extend.
Dit alles is te zien op figuur~\ref{fig:DatabaseCreatie}

\begin{figure}[H]
\centering
  	\includegraphics[width=.5\linewidth]{img/DatabaseCreatie.png}
  	\caption{Opbouw van een database}
  	\label{fig:DatabaseCreatie}
\end{figure}

Logfiles bevatten informatie nodig voor recovery.
De logfile-grootte is per default 25\% van grootte van de datafile.

In sql creëert men een database als volgt:
\begin{lstlisting}[language=sql]
CREATE DATABASE database_name
\end{lstlisting}

Men kan hierbij ook parameters meegeven:
\begin{lstlisting}[language=sql, breaklines=true]
CREATE DATABASE oefenDB 
ON PRIMARY(
	NAME = oefenDB_data,
	FILENAME = 'C:\Program Files\Microsoft SQL Server\ MSSQL.1\MSSQL\Data\oefenDB.mdf',
	SIZE = 10MB, MAXSIZE = 15MB, FILEGROWTH = 20%)
LOG ON (
	NAME = tttoefenDB_log,
	FILENAME = 'C:\Program Files\Microsoft SQL Server\ MSSQL.1\MSSQL\Data\oefenDB.ldf',
	SIZE = 3MB, MAXSIZE = 5MB, FILEGROWTH = 1MB)
\end{lstlisting}

\subsubsection{Een database verwijderen}
\begin{lstlisting}[language=sql, breaklines=true]
DROP DATABASE database_name
\end{lstlisting}

Hierbij dient opgemerkt te worden dat de systeem databank niet verwijderd kan worden.

\subsubsection{Een database wijzigen}
\begin{itemize}
\item beheer van de groei van de database en log file
\item uitbreiden/verminderen van grootte van database en log
\item toevoegen/verwijderen van secondary database files, log files
\end{itemize}

Wijzigen van de groote van het logbestand:
\begin{lstlisting}[language=sql, breaklines=true]
ALTER DATABASE oefenDB
MODIFY FILE (name = 'oefenDB_log', size = 10MB)
\end{lstlisting}

Toevoegen van een databastand:
\begin{lstlisting}[language=sql, breaklines=true]
ALTER DATABASE oefenDB
ADD FILE (
	name = oefenDB2,
	filename = 'C:\Program Files\Microsoft SQL Server\ MSSQL.1\MSSQL\Data\oefenDB2.ndf',
	size = 10MB,
	maxsize = 15MB)
\end{lstlisting}

\subsection{Tabellen}
\subsubsection{Een tabel creëren}
Bij de creatie van een tabel specifieren we:
\begin{itemize}
\item de naam van de tabel.
\item de definitie van de kolommen (naam, datatype \dots).
\item definitie van de constraints.
\end{itemize}

\begin{lstlisting}[language=sql, breaklines=true]
CREATE TABLE student(
	studentno int NOT NULL,
	lastname varchar(30) NOT NULL,
	firstname varchar(30) NOT NULL,
	gender char(1) NOT NULL,
	photograph image NULL)
\end{lstlisting}

\subsubsection{Een tabel wijzigen}
Mogelijke wijzigingen aan een tabel omvatten:
\begin{itemize}
\item toevoegen van kolommen.
\item wijzigen van kolommen.
\item verwijderen van kolommen.
\end{itemize}

\begin{lstlisting}[language=sql, breaklines=true]
ALTER TABLE student(
	ADD address varchar(40) NULL,
	ALTER COLUMN address varchar(50) NULL,
	DROP COLUMN address)
\end{lstlisting}

\subsubsection{Een tabel verwijderen}
Bij het verwijderen van een tabel diet men rekening te houden met de afhankelijkheden.

\begin{lstlisting}[language=sql, breaklines=true]
DROP TABLE student
\end{lstlisting}

\subsection{Contraints}
\subsubsection{Identity waarden}
Een identity kolom bevat voor elke rij een unieke waarde, die sequentieel door het systeem gegenereerd wordt.
Er is slechts één identity kolom per tabel mogelijk.
De identity kolom kan niet NULL zijn en kan niet door gebruikers aangepast worden.

\begin{lstlisting}[language=sql, breaklines=true]
CREATE TABLE studentVoorbeeldIdentity(
	studentno int identity(100, 5) NOT NULL,
	lastname varchar(30) NOT NULL,
	firstname varchar(30) NOT NULL,
	gender char(1) NOT NULL,
	photograph image NULL)
\end{lstlisting}

\subsubsection{Data integriteit}
Soorten:
\begin{itemize}
\item domein integriteit
\item entity integriteit
\item referentiële integriteit
\end{itemize}

\subsubsection{Definitie van constraints}
Via create table en als onderdeel van de kolomdefinitie:
\begin{lstlisting}[language=sql, breaklines=true]
CREATE TABLE studentVoorbeeldIdentity(
	studentno int NOT NULL unique)
\end{lstlisting}

Via alter table en als aparte lijn:
\begin{lstlisting}[language=sql, breaklines=true]
ALTER TABLE studentVoorbeeldIdentity(
	CONSTRAINT studentno_U unique(studentno)
\end{lstlisting}

Zowel bij creatie al bij wijzigen kan gekozen worden voor onderdeel van de kolomdefinitie als voor aparte lijn.
NULL en DEFAULT constraints kunnen enkel bij definitie van de kolom worden opgegeven.

\subsubsection{Check constraint}
\begin{lstlisting}[language=sql, breaklines=true]
gender char(1) default 'M' check(gender in ('M','F')) not null
\end{lstlisting}

\subsubsection{Primary key constraint}
\begin{lstlisting}[language=sql, breaklines=true]
studentno int primary key
\end{lstlisting}

of

\begin{lstlisting}[language=sql, breaklines=true]
constraint studentno_PK primary key(studentno)
\end{lstlisting}

\subsubsection{Foreign key constraint}
De foreign key wordt gebruikt om verbanden tussen relaties uit te drukken. NULL waarden zijn niet toegelaten.
\begin{lstlisting}[language=sql, breaklines=true]
constraint class_fk foreign key(class) references class(classID)
\end{lstlisting}
De foreign key legt ook de trapsgewijze (cascading) referentiële integriteitsacties vast.

\subsection{Views}
\subsubsection{Introductie}
Een view is een SELECT statement die onder een eigen naam wordt bewaard.
Een view is bijgevolg een soort virtuele tabel samengesteld uit andere tabellen of views.

De voordelen hiervan zijn dat de complexiteit van de database verborgen is.
Gebruikers krijgen functionaliteit en rechten op maat.
Views vereenvoudigen de beveiliging van de database.
Data wordt ook georganiseerd voor de export naar andere applicaties.

\begin{lstlisting}[language=sql, breaklines=true]
CREATE VIEW view_name [(column_list)]
AS select_statement
\end{lstlisting}

Views kunnen net als tabellen verwijders en gewijzigd worden.

\subsection{Indexen en performatie}
De heap is een ongeordende verzameling van data-pages zonder clustered index. Dit is de standaard opslag van een tabel.

Een index is een geordende structuur die op de records uit een tabel wordt gelegd.
Deze zijn snel toegankelijk dankzij een boomstructuur.
Dankzij indices kan de toegang tot data versnelt worden en kan uniciteit van de rijen afgedwongen worden.
Daarentegen nemen indexen veel opslagruimte in beslag en ze kunnen de performantie ook doen dalen.

\subsubsection{Clustered Index}
De fysische volgorde van de rijen in een tabel is deze van de clustered index.
Elke tabel kan maar één clustered index hebben.

De voordelen t.o.v. table scan zijn dat  een dubbel gelinkte lijst zorgt voor de volgorde bij het lezen van sequentiële records.
Er zijn ook geen forward pointers.
De clustered index legt unieke waarden op.

\begin{figure}[H]
\centering
  	\includegraphics[width=.35\linewidth]{img/ClusteredIndex.png}
  	\caption{Clustered index}
  	\label{fig:ClusteredIndex}
\end{figure}

\subsubsection{Non-clustered Index}
De non-clustered index is de default index, deze werkt trager dan de clustered index.
Wel zijn er meerdere non clustered indexen mogelijk per tabel.
Elke leaf bevat een sleutelwaarde en een row locator, deze wijst naar de positie in de clustered index als die bestaat, anders naar de heap.

\begin{figure}[H]
\centering
  	\includegraphics[width=.35\linewidth]{img/NonClusteredIndex.png}
  	\caption{Non-clustered index}
  	\label{fig:NonClusteredIndex}
\end{figure}

\subsubsection{Covering index}
Als een non-clustered indec een query niet volledig covert, dan moet de databank voor elke rij een lookup doen om de data op te halen.
Een covering index is in wezen een non-clustered index die alle kolommen bevat die nodig zijn voor een bepaalde query.

\subsubsection{Operaties op een index}
Creatie:
\begin{lstlisting}[language=sql, breaklines=true]
CREATE [UNIQUE] [CLUSTERED | NONCLUSTERED]
	INDEX index_naamON tabel(kolom[,...n])
\end{lstlisting}

Verwijderen:
\begin{lstlisting}[language=sql, breaklines=true]
DROP INDEX table_name.index_name[,...n]
\end{lstlisting}

\section{Postrelationele DBMS}
\subsection{SQL als volwaardige taal}
Procedurele uitbreidingen op SQL zijn merkgebonden. Database systemen die gebruik maken van deze uitbreidingen zijn dus moeilijker om te zetten van één RDBMS op een andere.

In het vervolg van deze samenvatting gaan we verder met t-SQL, die gebruikt wordt bij SQL Server.

De meeste database systemen voorzien al een aantal standaard SQl functies zoals minimum, maximum, som, gemiddelde, aantal \dots

SQL Server heeft nog een aantal extra functies zoals datediff, substring, len, round \dots

Naast deze functies is het ook nog mogelijk om user defined functies aan te maken.

\subsubsection{Voordelen van PSM}
\begin{itemize}
\item Code modularisatie
	\begin{itemize}
	\item reduceren redundante code: veel gebruikte queries in Stored Procedures en hergebruiken in 3GL.
	\item vaak voor de CRUD-operaties
	\item minder onderhoud bij schema-wijzigingen
	\end{itemize}
\item Security
	\begin{itemize}
	\item rechtstreekse queries op tabellen zijn uitgesloten
	\item via stored procedures vastleggen wat kan en wat niet
	\item vermijd SQL-injection, door gebruik input-parameters
	\end{itemize}
\item Centrale administratie van (delen van) DB-code.
\end{itemize}

\subsubsection{Nadelen van PSM}
\begin{itemize}
\item Beperkte schaalbaarheid
\item Vendor lock-in
	\begin{itemize}
	\item Er is geen standaard syntax
	\end{itemize}
\item Twee programmeertalen
\item Twee debugomgevingen
\item Beperkte OO-ondersteuning
\end{itemize}

\subsubsection{Vuistregels}
\begin{itemize}
\item Vermijd PSM voor grotere business logica
\item Gebruik PSM voor technische zaken: logging, auditing, validatie
\item Maak keuze voor portabiliteit/vendor lock-in in overleg met de business of corporate IT policies.
\end{itemize}

\subsubsection{Stored procedure}
Een stored procedure is een benoemde verzameling sql en control-of-flow opdrachten (programma) die opgeslagen wordt als een database object.
De stored procedure is analoog aan procedures uit andere talen.
Het kan aangeroepen worden vanuit een programma, trigger of stored procedure.

\subsection{Variabelen}
\subsubsection{Lokale variabelen}
\begin{lstlisting}[language=sql, breaklines=true]
DECLARE @lname varchar(40), @rijtelling int
SET @lname = 'Ringer'
SELECT @rijtelling = count(*)
FROM Authors
Where au_lname = @lname
PRINT 'Aantal werknemers met naam ' + @lname + ' = ' + str(@rijtelling)
\end{lstlisting}
Merk bij bovenstaande code op dat de naam van een variabele steeds wordt voorafgegaan door @.
Het toekennen van een waarde gebeurt via SET of SELECT

\subsubsection{Control flow met Transact SQL}
In een programma kan je het verloop bepalen via o.a.:
\begin{itemize}
\item Instructie niveau
	\begin{itemize}
	\item BEGIN ... END
	\item IF ... ELSE
	\item WHILE ...
		\begin{itemize}
		\item BREAK
		\item CONTINUE
		\end{itemize}
	\item RETURN
	\end{itemize}
\item Rij niveau
	\begin{itemize}
	\item CASE ... END
	\end{itemize}
\end{itemize}

\subsubsection{Gebruik van commentaar}
\begin{itemize}
\item Inline commentaar
	\begin{itemize}
	\item --commentaar
	\end{itemize}
\item Block commentaar
	\begin{itemize}
	\item /*commentaar*/
	\end{itemize}
\end{itemize}

\subsection{Cursors}
SQL statements werken standaar met een complete resultaatset en niet met individuele rijen. Cursors laten toe om met individuele rijen te werken.
Een cursor is dus een database object die wijst naar een resultaatset. Via de cursor kan men aangeven met wlke rij uit de resultaatset men wenst te werken.

\subsubsection{Declaratie van een cursor}
\begin{lstlisting}[language=sql, breaklines=true]
DECLARE <cursor_name> [INSENSITIVE][SCROLL] CURSOR FOR
<SELECT_statement>
[FOR {READ ONLY | UPDATE[OF <column list>]}]
\end{lstlisting}

\begin{itemize}
\item INSENSITIVE
	\begin{itemize}
	\item de cursor werkt met een tijdelijke kopie van de gegevens
		\begin{itemize}
		\item wijzigingen in onderliggende tabellen worden niet gereflecteerd in gegevens opgehaald via de cursor.
		\item de cursor kan niet gebruikt worden om tabellen te wijzigen
		\end{itemize}
	\item wanneer INSENSITIVE weggelaten wordt dan worden deletes en updates wel degelijk gereflecteerd in de cursor. 
	
	Dit is wel minder performant aangezien elke fetch nu resulteert in en nieuwe select opdracht.
	\end{itemize}
\item SCROLL
	\begin{itemize}
	\item alle soorten fetch operaties zijn bruikbaar
		\begin{itemize}
		\item FIRST, LAST, PRIOR, NEXT, RELATIVE en ABSOLUTE
		\end{itemize}
	\item wanneer SCROLL weggelaten wordt dan kan je enkel via NEXT data ophalen.
	\end{itemize}
\item READ ONLY
	\begin{itemize}
	\item verhindert dat je via de cursor de onderliggende tabellen kan wijzigen
	\item per default kan je via de cursor wel de onderliggende tabellen aanpassen
	\end{itemize}
\item UPDATE
	\begin{itemize}
	\item benoemen van specifieke kolommen die kunnen gewijzigd worden via de cursor.
	
	Enkel kolommen benoemd in deze clause kunnen gewijzigd worden.
	\end{itemize}
\end{itemize}

\subsubsection{Openen van een cursor}
\begin{lstlisting}[language=sql, breaklines=true]
OPEN <cursor name>
\end{lstlisting}

Hiermee wordt de cursor geopend en vervolgens opgevult met het SELECT statement dat in de declaratie was meegegeven.

De cursors current row pointer wordt gepositioneerd net voor de eerste rij in de actieve set.

\subsubsection{Data ophalen via een cursor}
\begin{lstlisting}[language=sql, breaklines=true]
FETCH[NEXT | PRIOR | FIRST | LAST | {ABSOLUTE|RELATIVE <rownumber>}]
FROM <cursor name>
[INTO <variable name> [,...<last variable name>]]
\end{lstlisting}
\begin{itemize}
\item De cursor wordt gepositioneerd
	\begin{itemize}
	\item op de "volgende" (of vorige, eerste, laatste\dots) rij
	\item per default wordt gepositioneerd via NEXT, voor andere manieren moet je een SCROLL-able cursor gebruiken.
	\end{itemize}
\item De gegevens worden opgehaald
	\begin{itemize}
	\item zonder INTO clause worden resulterende gegevens op het scherm getoond.
	\item met INTO clause worden gegevens in de opgegeven variabelen gestopt. Hierbij moet men opletten dat de variabelen gedeclareerd zijn.
	\end{itemize}
\end{itemize}

Een voorbeeld:
\begin{lstlisting}[language=sql, breaklines=true]
DECLARE @au_lname varchar(40), @au_fname varchar(20)
FETCH NEXT FROM authors_cursor
INTO @au_lname, @au_fname
WHILE @@FETCH_STATUS = 0 BEGIN
	PRINT 'Author: ' + @au_fname + ' ' + @au_lname
	FETCH NEXT FROM authors_cursor
	INTO @au_lname, @au_fname
END
\end{lstlisting}

\subsubsection{Sluiten van een cursor}
\begin{lstlisting}[language=sql, breaklines=true]
CLOSE <cursor_name>
\end{lstlisting}

\begin{itemize}
\item de cursor wordt gesloten
	\begin{itemize}
	\item de definitie van de cursor blijft bestaan
		\begin{itemize}
		\item er mogelijkheid om de cursor te heropenen
		\end{itemize}
	\end{itemize}
\end{itemize}

\subsubsection{Dealloceren van een cursor}
\begin{lstlisting}[language=sql, breaklines=true]
DEALLOCATE <cursor_name>
\end{lstlisting}


\begin{itemize}
\item de cursordefinitie wordt verwijderd
	\begin{itemize}
	\item wanneer dit de laatste referentie naar de cursor was dan worden alle resources voor die cursor vrijgegeven
	\item indien de cursor nog niet gesloten is da deallocate de cursor automatisch sluiten
		\begin{itemize}
		\item een close opdracht net voor een deallocatie opdracht hoeft dus niet
		\end{itemize}
	\end{itemize}
\end{itemize}

\subsubsection{Updaten via een cursor}
\begin{lstlisting}[language=sql, breaklines=true]
UPDATE <table name>
SET ...
WHERE CURRENT OF <cursor name>
\end{lstlisting}

\subsubsection{Verwijderen via een cursor}
\begin{lstlisting}[language=sql, breaklines=true]
DELETE FROM <table name>
WHERE CURRENT OF <cursor name>
\end{lstlisting}

\subsection{Stored Procedures}
\subsubsection{Creatie van een SP}
\begin{lstlisting}[language=sql, breaklines=true]
CREATE PROCEDURE <proc_name> [parameter declaratie]
AS
<sql_statements>
\end{lstlisting}
\begin{itemize}
\item aanmaken db-object: via DDL instructie
\item controle op syntax
	\begin{itemize}
	\item enkel indien syntactisch correct wordt de stored procedure opgeslaan in de catalogus.
	\end{itemize}
\end{itemize}

\subsubsection{Wijzigen van een SP}
\begin{lstlisting}[language=sql, breaklines=true]
ALTER PROCEDURE <proc_name> [parameter declaratie]
AS
<sql_statements>
\end{lstlisting}

\subsubsection{Verwijderen van een SP}
\begin{lstlisting}[language=sql, breaklines=true]
DROP PROCEDURE <proc_name>
\end{lstlisting}

\subsubsection{Uitvoeren van een SP}
\begin{lstlisting}[language=sql, breaklines=true]
EXCUTE <proc_name> [parameters]
\end{lstlisting}

\begin{itemize}
\item bij eerste uitvoering
	\begin{itemize}
	\item compilatie en optimalisatie
	\end{itemize}
\item hercompilatie forceren
	\begin{itemize}
	\item wenselijk bij wijzigingen aan structuur databank
	\begin{lstlisting}[language=sql, breaklines=true]
	execute uspOrdersSelectAll with recompile
	\end{lstlisting}
	\begin{lstlisting}[language=sql, breaklines=true]
	execute sp_recompile uspOrdersSelectAll
	\end{lstlisting}
	\end{itemize}
\end{itemize}

\subsubsection{De returnwaarde van een SP}
\begin{itemize}
\item Bij uitvoering keert een SP een returnwaarde terug
	\begin{itemize}
	\item deze waarde is een int
	\item de default return waarde is 0.
	\end{itemize}
\item return statement
	\begin{itemize}
	\item uitvoering van de SP wordt gestopt
	\item laat toe om de returnwaarde te bepalen
	\end{itemize}
\end{itemize}

Creatie van een SP met expliciete returnwaarde:
\begin{lstlisting}[language=sql, breaklines=true]
CREATE PROCEDURE usp_OrdersSelectAllAS
select * from orders
return @@ROWCOUNT
\end{lstlisting}

Gebruik van een SP met een returnwaarde:
\begin{lstlisting}[language=sql, breaklines=true]
DECLARE @returnCode int
EXEC @returnCode = usp_OrdersSelectAll
PRINT 'Er zijn ' + str(@returnCode) + ' records.'
\end{lstlisting}

\subsubsection{SP met parameters}
Via een input parameter kan men een waarde doorgeven aan de SP.

Via een output parameter kan men eventueel een waarde doorgeven aan de SP en krijgt men een waarde terug van de SP.

\begin{lstlisting}[language=sql, breaklines=true]
CREATE PROCEDURE usp_OrdersSelectAllForCustomer
@customerIDnchar(5) = 'ALFKI',
@count intOUTPUT
AS
SELECT @count = count(*)
FROM orders WHERE customerID= @customerID
\end{lstlisting}
Merk op dat 'ALFKI' een default waarde is die ingesteld wordt.

\begin{itemize}
\item aanroepen van de SP
	\begin{itemize}
	\item voorzie steeds het keyword OUTPUT voor output parameters
	\item twee manieren om actuele parameters door te geven
		\begin{itemize}
		\item gebruik formele parameternaam
		\item positioneel
		\end{itemize}
	\end{itemize}
\end{itemize}

Parameters via formele naam doorgeven:
\begin{lstlisting}[language=sql, breaklines=true]
DECLARE @aantal int
EXECUTE usp_OrdersSelectAllForCustomer
@customerID= 'ALFKI',
@count= @aantal OUTPUT
PRINT @aantal
\end{lstlisting}

Parameters positioneel doorgeven:
\begin{lstlisting}[language=sql, breaklines=true]
DECLARE @aantalint
EXEC usp_OrdersSelectAllForCustomer'ALFKI', @aantalOUTPUT
PRINT @aantal
\end{lstlisting}

\subsubsection{Error handling}
@@erroris een systeemfunctie die het foutnummer bevat van de laatst uitgevoerde opdracht. De waarde 0 wijst op succesvolle uitvoering.

Alle foutboodschappen zitten in de systeemtabel sysmessages.
\begin{lstlisting}[language=sql, breaklines=true]
SELECT * FROM master.dbo.sysmessages
WHERE error = @@ERROR
\end{lstlisting}
Eigen fouten kan men genereren via raiseerror(msg,severity,state)
\end{document}